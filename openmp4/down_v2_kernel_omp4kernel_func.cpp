//
// auto-generated by op2.py
//

#include <math.h>
#include "const.h"

void down_v2_kernel_omp4_kernel(
  int *map0,
  int map0size,
  int *map2,
  int map2size,
  double *data0,
  int dat0size,
  double *data2,
  int dat2size,
  double *data4,
  int dat4size,
  double *data6,
  int dat6size,
  double *data8,
  int dat8size,
  int *col_reord,
  int set_size1,
  int start,
  int end,
  int num_teams,
  int nthread){

  #pragma omp target teams num_teams(num_teams) thread_limit(nthread) \
    map(to:col_reord[0:set_size1],map0[0:map0size],map2[0:map2size],data0[0:dat0size],data2[0:dat2size],data4[0:dat4size],data6[0:dat6size],data8[0:dat8size])
  #pragma omp distribute parallel for schedule(static,1)
  for ( int e=start; e<end; e++ ){
    int n_op = col_reord[e];
    int map0idx;
    int map1idx;
    int map2idx;
    int map3idx;
    map0idx = map0[n_op + set_size1 * 0];
    map1idx = map0[n_op + set_size1 * 1];
    map2idx = map2[n_op + set_size1 * 0];
    map3idx = map2[n_op + set_size1 * 1];

    //variable mapping
    const double* coord2a = &data0[3 * map0idx];
    const double* coord2b = &data0[3 * map1idx];
    const double* coord1a = &data2[3 * map2idx];
    const double* coord1b = &data2[3 * map3idx];
    const double* residuals1a = &data4[5 * map2idx];
    const double* residuals1b = &data4[5 * map3idx];
    double* residuals1a_prolonged = &data6[5 * map0idx];
    double* residuals1b_prolonged = &data6[5 * map1idx];
    double* residuals1a_prolonged_wsum = &data8[1 * map0idx];
    double* residuals1b_prolonged_wsum = &data8[1 * map1idx];

    //inline function
    







      double dx_a1a2 = coord2a[0] - coord1a[0];
      double dy_a1a2 = coord2a[1] - coord1a[1];
      double dz_a1a2 = coord2a[2] - coord1a[2];
      if (dx_a1a2 == 0.0 && dy_a1a2 == 0.0 && dz_a1a2 == 0.0) {

          residuals1a_prolonged[VAR_DENSITY]        = residuals1a[VAR_DENSITY];
          residuals1a_prolonged[VAR_MOMENTUM+0]     = residuals1a[VAR_MOMENTUM+0];
          residuals1a_prolonged[VAR_MOMENTUM+1]     = residuals1a[VAR_MOMENTUM+1];
          residuals1a_prolonged[VAR_MOMENTUM+2]     = residuals1a[VAR_MOMENTUM+2];
          residuals1a_prolonged[VAR_DENSITY_ENERGY] = residuals1a[VAR_DENSITY_ENERGY];
          *residuals1a_prolonged_wsum = 1.0;
      } else {

          const double idist_a1a2 = 1.0/sqrt(dx_a1a2*dx_a1a2 + dy_a1a2*dy_a1a2 + dz_a1a2*dz_a1a2);
          residuals1a_prolonged[VAR_DENSITY]        += idist_a1a2*residuals1a[VAR_DENSITY];
          residuals1a_prolonged[VAR_MOMENTUM+0]     += idist_a1a2*residuals1a[VAR_MOMENTUM+0];
          residuals1a_prolonged[VAR_MOMENTUM+1]     += idist_a1a2*residuals1a[VAR_MOMENTUM+1];
          residuals1a_prolonged[VAR_MOMENTUM+2]     += idist_a1a2*residuals1a[VAR_MOMENTUM+2];
          residuals1a_prolonged[VAR_DENSITY_ENERGY] += idist_a1a2*residuals1a[VAR_DENSITY_ENERGY];
          *residuals1a_prolonged_wsum += idist_a1a2;

          double dx_b1a2 = coord1b[0] - coord2a[0];
          double dy_b1a2 = coord1b[1] - coord2a[1];
          double dz_b1a2 = coord1b[2] - coord2a[2];

          const double idist_b1a2 = 1.0/sqrt(dx_b1a2*dx_b1a2 + dy_b1a2*dy_b1a2 + dz_b1a2*dz_b1a2);
          residuals1a_prolonged[VAR_DENSITY]        += idist_b1a2*residuals1b[VAR_DENSITY];
          residuals1a_prolonged[VAR_MOMENTUM+0]     += idist_b1a2*residuals1b[VAR_MOMENTUM+0];
          residuals1a_prolonged[VAR_MOMENTUM+1]     += idist_b1a2*residuals1b[VAR_MOMENTUM+1];
          residuals1a_prolonged[VAR_MOMENTUM+2]     += idist_b1a2*residuals1b[VAR_MOMENTUM+2];
          residuals1a_prolonged[VAR_DENSITY_ENERGY] += idist_b1a2*residuals1b[VAR_DENSITY_ENERGY];
          *residuals1a_prolonged_wsum += idist_b1a2;
      }

      double dx_b1b2 = coord2b[0] - coord1b[0];
      double dy_b1b2 = coord2b[1] - coord1b[1];
      double dz_b1b2 = coord2b[2] - coord1b[2];
      if (dx_b1b2 == 0.0 && dy_b1b2 == 0.0 && dz_b1b2 == 0.0) {

          residuals1b_prolonged[VAR_DENSITY]        = residuals1b[VAR_DENSITY];
          residuals1b_prolonged[VAR_MOMENTUM+0]      = residuals1b[VAR_MOMENTUM+0];
          residuals1b_prolonged[VAR_MOMENTUM+1]      = residuals1b[VAR_MOMENTUM+1];
          residuals1b_prolonged[VAR_MOMENTUM+2]      = residuals1b[VAR_MOMENTUM+2];
          residuals1b_prolonged[VAR_DENSITY_ENERGY] = residuals1b[VAR_DENSITY_ENERGY];
          *residuals1b_prolonged_wsum = 1.0;
      } else {

          const double idist_b1b2 = 1.0/sqrt(dx_b1b2*dx_b1b2 + dy_b1b2*dy_b1b2 + dz_b1b2*dz_b1b2);
          residuals1b_prolonged[VAR_DENSITY]        += idist_b1b2*residuals1b[VAR_DENSITY];
          residuals1b_prolonged[VAR_MOMENTUM+0]     += idist_b1b2*residuals1b[VAR_MOMENTUM+0];
          residuals1b_prolonged[VAR_MOMENTUM+1]     += idist_b1b2*residuals1b[VAR_MOMENTUM+1];
          residuals1b_prolonged[VAR_MOMENTUM+2]     += idist_b1b2*residuals1b[VAR_MOMENTUM+2];
          residuals1b_prolonged[VAR_DENSITY_ENERGY] += idist_b1b2*residuals1b[VAR_DENSITY_ENERGY];
          *residuals1b_prolonged_wsum += idist_b1b2;

          double dx_a1b2 = coord1a[0] - coord2b[0];
          double dy_a1b2 = coord1a[1] - coord2b[1];
          double dz_a1b2 = coord1a[2] - coord2b[2];

          const double idist_a1b2 = 1.0/sqrt(dx_a1b2*dx_a1b2 + dy_a1b2*dy_a1b2 + dz_a1b2*dz_a1b2);
          residuals1b_prolonged[VAR_DENSITY]        += idist_a1b2*residuals1b[VAR_DENSITY];
          residuals1b_prolonged[VAR_MOMENTUM+0]     += idist_a1b2*residuals1b[VAR_MOMENTUM+0];
          residuals1b_prolonged[VAR_MOMENTUM+1]     += idist_a1b2*residuals1b[VAR_MOMENTUM+1];
          residuals1b_prolonged[VAR_MOMENTUM+2]     += idist_a1b2*residuals1b[VAR_MOMENTUM+2];
          residuals1b_prolonged[VAR_DENSITY_ENERGY] += idist_a1b2*residuals1b[VAR_DENSITY_ENERGY];
          *residuals1b_prolonged_wsum += idist_a1b2;
      }
    //end inline func
  }

}
